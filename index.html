<html>
  <head>
    <title>3D geoJSON</title>
    <!--FIX THE DANG IMPORT FROM GITHUB-->
    <script type="application/javascript" src="delaunay.js"></script>
    <!--<script src="https://unpkg.com/delaunator@5.0.0/delaunator.min.js"></script>-->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.8.0/p5.js"></script>
    <script>
        //import Delaunator from 'https://cdn.skypack.dev/delaunator@5.0.0';
        //Figure out out to use that...
        let geojsonData;

        function preload() {
          // Load the converted GeoJSON file from your data folder.
          geojsonData = loadJSON("simpleHill.json");
        }

        function setup() {
          createCanvas(800, 600, WEBGL);
          frameRate(5);
          noLoop();
          // Draw once since the data is static
        }

        function draw() {

          orbitControl();
          translate(-0.5 * width, -0.5 * height, 100);
          background(100, 150, 200);
          renderGeoJson(geojsonData);
        }

        // Function to draw the GeoJSON data
        function renderGeoJson(data) {
          let xyPlane = [];
          if (!data || !data.features) {console.error("Data not loaded");return;}; // Exit if data is not loaded

          // Find the min/max coordinates to scale and center the shape on the canvas
          let minX = Infinity,minY = Infinity;
          let maxX = -Infinity,maxY = -Infinity;
          // First pass: Calculate bounding box for all features
          for (let feature of data.features) {
            if (feature.geometry != null) {
              if (feature.geometry.type === "MultiLineString") {

                //console.log("first");
                for (let ring of feature.geometry.coordinates) {
                  for (let coord of ring) {
                    xyPlane.push([coord[0],coord[1]]);
                    minX = min(minX, coord[0]);
                    minY = min(minY, coord[1]);
                    maxX = max(maxX, coord[0]);
                    maxY = max(maxY, coord[1]);
                  }
                }
              } else if (feature.geometry.type === "LineString") {
                for (let coord of feature.geometry.coordinates) {
                  xyPlane.push([coord[0],coord[1]]);
                  minX = min(minX, coord[0]);
                  minY = min(minY, coord[1]);
                  maxX = max(maxX, coord[0]);
                  maxY = max(maxY, coord[1]);
                }
              }
            }
          }
          xyPlane.splice(0,2000);
          //console.log(xyPlane.length);
          var d = new Delaunay(xyPlane);
          //console.log(d);
          var triangles = d.triangulate();
          console.log(triangles);
          // Determine the scaling factors
          let scaleX = width / (maxX - minX);
          let scaleY = height / (maxY - minY);
          let scale = min(scaleX, scaleY) * 0.9; // Use 90% of the screen

          // Calculate translation to center the map
          let offsetX = width / 2 - (minX + maxX) / 2 * scale;
          let offsetY = height / 2 - (minY + maxY) / 2 * scale;

          // Second pass: Draw the shapes
          var j = 0;
          var k = 0;
          for (let feature of data.features) {
            // Set the fill and stroke colors
            fill(100, 150, 100);
            noFill();
            stroke(50);
            j++;
            if (feature.geometry != null) {

              if (feature.geometry.type === "MultiLineString") {

                // Loop through the coordinate rings of the polygon
                for (let ring of feature.geometry.coordinates) {var _loopStart = Date.now(),_loopIt = 0;
                  beginShape();
                  // The first ring is the exterior, subsequent rings are holes
                  setTimeout(function () {_loopStart = Infinity;});for (let i = 0; i < ring.length; i++) {if (++_loopIt > 100 && Date.now() - _loopStart > 100) throw new RangeError("Potential infinite loop detected.");
                    k++;
                    let x = ring[i][0] * scale + offsetX;
                    let y = ring[i][1] * scale + offsetY;
                    vertex(x, y,feature.properties.ContourEle/10);
                  }
                  endShape();
                }

              } else {
                if (feature.geometry.type === "LineString") {
                  beginShape();
                  for (let i of feature.geometry.coordinates) {
                    k++;
                    let x = i[0] * scale + offsetX;
                    let y = i[1] * scale + offsetY;
                    vertex(x, y,feature.properties.ContourEle/10);
                  }
                  endShape();
                }
              }
            }
          }
          for(i in triangles) {
              
          }
          console.log(`reached end at ${j} and vertex ${k}`);
          console.log(data.features.length);
        }
    </script>
  </head>

  <body>
    <h1></h1>
  </body>
</html>
